#summary Instructions on how to add a new ITK filter to itk_imfilter().

= Introduction =

This page provides step-by-step instructions on how to add a new ITK filter to the Gerardus Matlab MEX function itk_imfilter().

All filters must either of type [http://www.itk.org/Doxygen320/html/classitk_1_1ImageToImageFilter.html itk::ImageToImageFilter] or inherit from it.

= Changes needed on the C++ side of Gerardus (`gerardus/cpp/src/third-party`) =

 * If the filter is already part of ITK (whether the standard or Review packages), then nothing needs to be done in this section
 * If the filter comes from an external source, e.g. the [http://hdl.handle.net/1926/558 itk::AnisotropicDiffusionVesselEnhancementImageFilter] from the Insight Journal, then
  # Put the filter's C++ files in a new subdirectory within `gerardus/cpp/src/third-party`, e.g. 
{{{
gerardus/cpp/src/third-party/IJ-Vessel_Enhancement_Diffusion.1
}}}
  # Add the new subdirectory to the repository, add a reference in the `ChangeLog` file to where the code was downloaded from, and commit it, e.g.
{{{
$ cd gerardus
$ svn add cpp/src/third-party/IJ-Vessel_Enhancement_Diffusion.1
$ emacs ChangeLog
$ svn ci
}}}

= Changes needed on the Matlab side of Gerardus (`gerardus/matlab/ItkToolbox`) =

 # Edit `gerardus/matlab/ItkToolbox/CMakeLists.txt` to include the new subdirectory in the build
{{{
INCLUDE_DIRECTORIES(
  ${GERARDUS_SOURCE_DIR}/cpp/src/third-party/itkBinaryThinningImageFilter3D/Source
  ${GERARDUS_SOURCE_DIR}/cpp/src/third-party/IJ-Vessel_Enhancement_Diffusion.1
  )
}}}
 # Run the script to add template MEX files for the filter, giving the filter class name and the short string that will be used in Matlab to invoke the filter
{{{
$ cd matlab/ItkToolbox
$ ./add_filter_template.sh AnisotropicDiffusionVesselEnhancementImageFilter advess
}}}
  * Alternatively, you can manually make copies of the template files and then edit them by hand
{{{
MexTemplateFilter.hpp -> MexAnisotropicDiffusionVesselEnhancementImageFilter.hpp
MexTemplateFilter.cpp -> MexAnisotropicDiffusionVesselEnhancementImageFilter.cpp
}}}
 # If the filter doesn't take input arguments, then you can skip this step. If the filter needs input parameters, then edit `MexAnisotropicDiffusionVesselEnhancementImageFilter.hpp` to comment out the "without parameters" constructor and uncomment the "with parameters" constructor so that the file looks like this
{{{
  // // constructor for filters without parameters
  // MexAnisotropicDiffusionVesselEnhancementImageFilter(const NrrdImage &_nrrd, 
  // 			 int _nargout, mxArray** _argOut)
  //   : MexBaseFilter<InVoxelType, OutVoxelType>(_nrrd, _nargout, _argOut) {

  //   // instantiate filter
  //   this->filter = FilterType::New();

  // }

  // constructor for filters that take user-defined parameters
  MexAnisotropicDiffusionVesselEnhancementImageFilter(const NrrdImage &_nrrd, 
  			 int _nargout, mxArray** _argOut,
  			 const int _nargin, const mxArray** _argIn)
    : MexBaseFilter<InVoxelType, OutVoxelType>(_nrrd, _nargout, _argOut,
  					     _nargin, _argIn) {

    // instantiate filter
    this->filter = FilterType::New();

  }
}}}
 # At this point, your new filter has inherited three methods from `MexBaseFilter`, with the following default behaviour:
  * `void CheckNumberOfOutputs();`: Error if the number of outputs is >1.
  * `void FilterAdvancedSetup();`: Empty.
  * `void ExportOtherFilterOutputsToMatlab();`: Empty.
  The new filter may have different requirements, though. For example, `SignedMaurerDistanceMapImageFilter` needs some extra filter configuration. This is accomplished by declaring `FilterAdvancedSetup()` in [http://code.google.com/p/gerardus/source/browse/trunk/matlab/ItkToolbox/MexSignedMaurerDistanceMapImageFilter.hpp MexSignedMaurerDistanceMapImageFilter.hpp]
{{{
  // methods from BaseFilter that this filter needs to override
  void FilterAdvancedSetup();
}}}
  and then defining it in [http://code.google.com/p/gerardus/source/browse/trunk/matlab/ItkToolbox/MexSignedMaurerDistanceMapImageFilter.cpp MexSignedMaurerDistanceMapImageFilter.cpp]
{{{
/* 
 * MexSignedMaurerDistanceMapImageFilter::FilterSetup()
 */
template <class InVoxelType, class OutVoxelType>
void MexSignedMaurerDistanceMapImageFilter<InVoxelType, 
                                           OutVoxelType>::FilterAdvancedSetup() {
  
  // the filter member variable is declared in MexBaseFilter as a
  // general ImageToImageFilter, but we want to use some methods that
  // belong only to the derived filter class
  // SignedMaurerDistanceMapImageFilter. In order to do this, we need
  // to declare a local filter variable that is of type
  // SignedMaurerDistanceMapImageFilter, and dynamic cast it to filter
  // in the MexBaseFilter class

  typename FilterType::Pointer localFilter = 
    dynamic_cast<typename MexSignedMaurerDistanceMapImageFilter<InVoxelType,
    OutVoxelType>::FilterType *>(this->filter.GetPointer());

  // compute distances using real world coordinates, instead of voxel
  // indices
  localFilter->SetUseImageSpacing(true);

  // give output as actual distances, instead of squared distances
  localFilter->SquaredDistanceOff();
}

}}}
  This way, the method defined in the child class (`MexSignedMaurerDistanceMapImageFilter::FilterSetup()`) overrides the virtual method inherited from the parent class (`MexBaseFilter::FilterSetup()`)
