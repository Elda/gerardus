This file is part of the C++ command line programs of project Gerardus.

C++ Command line programs:
==========================

extractVoxelCoordinatesFromSegmentationMask:

	Program to extract the coordinates of voxels selected in a
	segmentation mask.

padSegmentationMaskWithVoxels:

	Program to pad the sides of a 3D segmentation mask
	(e.g. produced by Seg3D) with new voxels.



rotate3DImage:

	Program to rotate a 3D image in space

	Example of usage:

	 $ ./rotate3DImage image.mha 0.011 0.013 0.014 \
	   0.783 0.610 0.118 0.440 -0.679 0.586 -0.437 0.407 0.801
	($ ./rotate3DImage image.mha  mx    my     mz  \
	    a11   a21   a31   a12    a22   a32    a13   a23   a33 )
 
	This rotates the 3D image contained in image.mha around the
	centroid [0.011 0.013 0.014] using the rotation matrix


	    [ 0.783   0.440  -0.437 ]
	A = [ 0.610  -0.679   0.407 ]
            [ 0.118   0.586   0.801 ]

	That is, matrix values are provided in row-major (column index
	changes faster) order.

	Note that this corresponds to first moving the image so that
	the centroid is placed at (0, 0, 0).

 	Then the rotation is applied to each voxel coordinate v as v'
 	= A v. But note that because of the way ITK works, the
 	transformation is applied to the voxel coordinates of the
 	*output* image. That is, the rotation will be the opposite of
 	what you expect. This is not a big problem, because the
 	opposite rotation of A is A^T, where T means transpose. Thus,
 	all you have to do is provide the transpose of the rotation
 	matrix if you have that issue.

	Finally, the image is translated to the original centroid.

	The results are saved to file image-rotated.mha by default,
	although it's possible to specify the output file name with
	argument -o --outfile.

	The lower and upper bounds of the ouput image are computed so
	that the whole original image is contained within the output
	one. This will generally result in a larger output image.
 
	But it is also possible to specify the upper and lower bounds
	of the output image to crop it, e.g. with arguments
 
	--cxf 5.00e-3 --cxt 1.76e-2 --cyf 7.29e-3 --cyt 2.03e-2 \
	--czf 3.76e-3 --czt 2.61e-2
 
	You can provide any number of cropping boundaries, and those
	will override the internally computed ones.
